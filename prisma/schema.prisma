
datasource db {
  provider = "postgresql" // or your DB provider
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}


model Expense {
  id          Int         @id @default(autoincrement())
  splitId     Int        @unique
  description String?
  totalAmount String      
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  split       Split        @relation(fields: [splitId], references: [id], onDelete: Cascade)
  userExpenses UserExpense[]

  @@map("expense")
  @@index([splitId])
  @@index([createdAt])
}

model Friends {
  id        Int     @id @default(autoincrement())
  userId    Int
  friendId  Int
  createdAt DateTime @default(now()) 

  user      User     @relation("UserFriends", fields: [userId], references: [id])
  friend    User     @relation("Friendships", fields: [friendId], references: [id])

  
  @@map("friends")
  @@unique([userId, friendId]) // Prevent duplicate friendships
  @@index([userId])
  @@index([friendId])
  @@index([createdAt])
}

model Message {
    id Int @id @default(autoincrement())
    senderId String
    receiverId String
    message String
    createdAt DateTime @default(now())
    updatedAt  DateTime @updatedAt()
}

model OtpLog {
    id Int @id @default(autoincrement())
    configLength String
    token String
    email String
    lifetime DateTime
    isDeactivated Boolean
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt 

  @@map("otp_log")
}
model Split {
  id         Int          @id @default(autoincrement())
  name       String
  category   String
  totalAmount String      
  percentage Float?       @default(0.00)
  creatorId Int      
  status String @default("ACTIVE")
  createdAt  DateTime      @default(now()) 
  updatedAt  DateTime      @updatedAt

  creator   User     @relation("CreatedSplits", fields: [creatorId], references: [id])  // Link to User entity  
  expense   Expense?
  users      SplitUser[]

  @@map("split")
  @@index([id])
  @@index([creatorId])
  @@index([createdAt])
}

model SplitUser {
  id        Int     @default(autoincrement())
  splitId   Int
  userId    Int
  createdAt DateTime @default(now()) 

  split     Split  @relation(fields: [splitId], references: [id], onDelete: Cascade)
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([splitId, userId])
  @@map("split_users")
}

 model User {
  id        Int       @id @default(autoincrement())
  username  String?   @unique
  name      String
  email     String    @unique
  password  String?
  avatar    String?
  lastLogin DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime  @default(now())
  
  friends   Friends[]  @relation("UserFriends")
  beFriends Friends[]  @relation("Friendships")
  expenses  UserExpense[]
  participantSplits    SplitUser[]
  createdSplits    Split[]  @relation("CreatedSplits")  // Relation field for splits created by the user


  @@index([email])
  @@index([id])
  @@index([createdAt])
  @@map("user")
}

model UserExpense {
  id         Int         @id @default(autoincrement())
  userId     Int
  expenseId  Int
  amountPaid String?    @default("0")  
  amountOwed String     @default("0")
  percentage Float      
  receipt    String?
  isPaid     Boolean       @default(false)
  status     String         @default("UNPAID")
  createdAt  DateTime     @default(now()) 
  updatedAt  DateTime     @updatedAt

  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  expense    Expense      @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  @@map("user_expenses")
  @@index([expenseId])
  @@index([userId])
  @@index([createdAt])
  @@index([expenseId, userId]) // Composite index

}

model ValidationLog {
    id Int @id @default(autoincrement())
    uniqueId String
    status String
    message String
    field String
    createdAt DateTime @default(now()) 
    updatedAt DateTime @updatedAt 

  @@map("validation_log")
}